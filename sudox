#!/usr/bin/env sh
# (C) Martin V\"ath <martin@mvath.de>
set -u
set -f

# Some paranoia if /bin/sh is bash -
# after all, this script is highly security relevant:
[ -z "${BASH++}" ] || set -p
unset IFS BASH_ENV ENV SHELL_OPTS || exit 2
BASH_ENV=
ENV=
SHELL_OPTS=
[ -z "$BASH_ENV$ENV$SHELL_OPTS" ] || exit 2

# Actually, these are two scripts: The "main" script is documented
# in the "Usage" function below. However, this script is also
# called implicitly on the remote side.
# The "Usage" on the remote side is never printed by this script,
# because it is not supposed to be called by the user (and it might
# change in future versions).
# Currently, the syntax for the remote side is as follows:
#
# "$0" '-remotecall' "$SHELL" "$DISPLAY" \
#        'Name of fifo used to transfer data'|'~$XAUTHORITY'|'' \
#        display1 display2 ... '-dispend;' \
#        command [args for command]
#
# The actual authorization data is not passed as an arg but via the fifo.
# First, some helper functions needed for both parts of the script:

Echo() {
	printf '%s\n' "$*"
}

MsgErr() {
	Echo "$*" >&2
}

Warning() {
	MsgErr "${0##*/}: $*"
}

Fatal() {
	Warning "$*"
	exit 2
}

Push() {
	. push.sh
	Push "$@"
}

DoExec() {
	if [ $# -eq 0 ]
	then	exec "${SHELL:-sh}"
	else	Push -c mycmd ${1+"$@"}
		exec "${SHELL:-sh}" -c "$mycmd"
	fi
	Fatal "cannot execute ${SHELL:-sh}"
}

# Now the remote part of the script:

AddAuthorities() {
	for a
	do	printf '%s' "$a" | xauth nmerge -
	done
}

Troyan() {
	Fatal "$1. Probably some Troyan running"
}

NonMatch() {
	Fatal "$1. Client and server versions do not match"
}

ReadTransfer() {
	read -r count || Troyan 'unreadable fifo'
	case ${count:-x} in
	*[!0123456789]*)
		Troyan 'corruption with fifo';;
	esac
	if [ "$count" -gt 0 ]
	then	transfer=`dd bs="$count" count=1 2>/dev/null && echo x` || \
			Troyan 'corruption with fifo'
		transfer=${transfer%x}
		[ $count -eq ${#transfer} ] || Troyan 'corruption with fifo'
	fi
	eval "AddAuthorities $transfer"
	:
}

ParseFifo() {
	test -p "$1" || Troyan "no fifo $1"
	# || exit, because redirection might start a subshell
	ReadTransfer <"$1" || exit
}

if [ x"${1-}" = x'-remotecall' ]
then	shift
	[ $# -ge 4 ] || NonMatch 'not enough remote arguments'
	SHELL=$1
	[ -z "${SHELL:++}" ] || export SHELL
	[ -z "${2:++}" ] || {
		DISPLAY=$2
		export DISPLAY
	}
	if [ -n "${XAUTHORITY++}" ]
	then	xauthority=$XAUTHORITY
		unset XAUTHORITY
	else	unset xauthority
	fi
	fifo=
	[ -z "$3" ] || case $3 in
	'~'*)
		xauthority=${3#?};;
	*)
		unset xauthority
		fifo=$3;;
	esac
	shift 3
	while [ x"$1" != x'-dispend;' ]
	do	xauth -q remove "$1" >/dev/null 2>&1
		shift
		[ $# -gt 0 ] || NonMatch 'no "-dispend;"'
	done
	shift
	[ -z "${fifo:++}" ] || ParseFifo "$fifo"
	[ -z "${xauthority++}" ] || {
		XAUTHORITY=$xauthority
		export XAUTHORITY
	}
	SUDO_COMMAND=${*-}
	DoExec ${1+"$@"}
fi

# Now the main part of the script (i.e. the "server" side called by the user):

Version() {
	Echo 'sudox 5.0.0'
	exit 0
}

Usage() {
	Echo "Usage: ${0##*/} [options] [user [command]]
Similar to sudo -H -u user -s -- but transfer also X authority data.
Most options are passed to sudo, essentially with the following exceptions:
-l Clear STY/TMUX for the command/session (mnemonic: login environment)
-e Work only if not in a screen/tmux environment (STY/TMUX)
-p Without this option, -A is passed to sudo when SUDO_ASKPASS is set
-T Do not call \"script\" to open a new tty; security risk if interactive.
   If -xT are used but not -s/-S/-U, then act similar to sudo -H -u user --
   This is useful if special entries in /etc/sudoers should be prepared.
-s Start a tmux (fallback to screen) session
-S Start a screen (fallback to tmux) session
-x Do not transfer any X authority data. If this option is used, -u is ignored
-u Generate only an untrusted permission. (This requires that your xorg-server
   was compiled with --enable-xcsecurity.) This option implies -R
-t TIMEOUT (in seconds). Time for which the untrusted permission is valid.
   The value 0 (default) means: forever
   This option is ignored without -u
-U Delete all related X authority data of the new user (similar to -ut1).
   If combined with -r, the new user might have access to X anyway
-r Assume that XAUTHORITY (defaults to ~/.Xauthority) is readable by the
   destination user and transfer XAUTHORITY for X cookies.
   This makes it unnecessary to pass cookies through a fifo
   (more secure and the sudox process can terminate).
   This is the default without -u if user is root
-R Cancel -r, even if user is root. This is the default with -u
-V Print version
-h Print this help
If the specified user is empty, nothing is done (succesfully), so that
sudox -e '' can be used to only check the environment. In that case a
second argument (if provided) is used for the program name for -e failure"
	exit ${1:-1}
}

tmpdir=
RmTemp() {
	trap : EXIT HUP INT TERM
	[ -n "${tmpdir:++}" ] && test -d "$tmpdir" && rm -rf -- "$tmpdir"
	tmpdir=
	ClearTrap
}

retvalue=0
MyTrap() {
	RmTemp
	exit $retvalue
}

ClearTrap() {
	trap - EXIT HUP INT TERM
}

MkTemp() {
	[ -n "${tmpdir:++}" ] && return
	trap MyTrap EXIT HUP INT TERM
	if command -v mktemp >/dev/null 2>&1
	then	tmpdir=`umask 077 && mktemp -d -- "${TMPDIR:-/tmp}/${0##*/}.XXXXXXXX"` \
			&& [ -n "${tmpdir:++}" ] && test -d "$tmpdir" && return
		ClearTrap
		ErrMessage 'cannot create temporary directory'
		return 2
	fi
	if [ -z "${have_random:++}" ]
	then	r=${RANDOM-}
		if [ x"$r" = x"${RANDOM-}" ] && [ x"$r" = x"${RANDOM-}" ]
		then	have_random=false
			r=`od -d -N2 /dev/random 2>/dev/null` || r=
			r=`printf '%s' $r`
			if [ -z "${r:++}" ]
			then	r=1
			else	r=$(( $r % 32768 ))
				[ "$r" -eq 0 ] && r=1
			fi
		else	have_random=:
		fi
		t=
	fi
	c=0
	while [ $c -le 999 ]
	do	if [ -n "${t:++}" ]
		then	if $have_random
			then	r=$RANDOM
			else	r=$(( $r * 13821 ))
				r=$(( $r % 32768 ))
			fi
		fi
		t=${TMPDIR:-}/tmp/${0##*/}.$$$c$r
		mkdir -m 700 -- "$t" && tmpdir=$t && return
		c=$(( $c + 1 ))
	done
	ClearTrap
	ErrMessage 'cannot create temporary directory'
	return 2
}

# Parse options

askpass=:
untrusted=false
deletex=false
timeout=0
xtransfer=:
screen=
script=:
checkenv=false
loginenv=false
rootmode=
Push -c sudoargs
OPTIND=1
while getopts "leTUut:xHrRsSyYh?Va:c:g:r:inkKbPAE" opt
do	case $opt in
	l)	loginenv=:;;
	e)	checkenv=:;;
	p)	askpass=false;;
	T)	script=;;
	U)	deletex=:;;
	u)	untrusted=:;;
	t)	timeout=$OPTARG;;
	x)	xtransfer=false;;
	r)	rootmode=:;;
	R)	rootmode=false;;
	s)	screen='tmux screen';;
	S)	screen='screen tmux';;
	H)	:;;
	V)	Version;;
	[h?])	Usage;;
	[acgpr])
		Push sudoargs "-$opt" "$OPTARG";;
	*)	Push sudoargs "-$opt";;
	esac
done
shift $(( $OPTIND - 1 ))

# Check/modify environment first

if $checkenv && [ -n "${STY++}${TMUX++}" ]
then	if [ $# -eq 2 ] && [ -z "$1" ]
	then	name=$2
	else	name=${0##*/}
	fi
Fatal() {
	MsgErr "$name: terminating: $*"
	exit 1
}
	[ -z "${STY++}" ] || {
		[ -z "${TMUX++}" ] || Fatal 'screen and tmux both seem to be running.'
		Fatal 'screen seems to be running.'
	}
	Fatal 'tmux seems to be running.'
fi
! $loginenv || unset STY TMUX

# Parse remainder

Push sudoargs -H
remoteuse=root
if [ $# -gt 0 ]
then	remoteuse=$1
	[ -n "$remoteuse" ] || exit 0
	shift
	Push sudoargs "-u" "$remoteuse"
fi

# Implicit option dependencies

$xtransfer || untrusted=false
! $untrusted || rootmode=false
[ -n "$rootmode" ] || if [ "$remoteuse" = 'root' ]
then	rootmode=:
else	rootmode=false
fi

# Calculate/check correct screen program, possibly unsetting environment

if [ -n "${screen:++}" ]
then	for screenprg in $screen
	do	if screen=`PATH=/bin:/usr/bin::/sbin:/usr/sbin${PATH:+:}${PATH-} \
command -v "$screenprg" 2>/dev/null` && [ -n "${screen:++}" ]
		then	case $screenprg in
			screen)
				unset STY;;
			tmux)
				unset TMUX;;
			esac
			break
		else	screen=
		fi
	done
	[ -z "${screen:++}" ] || Fatal 'tmux/screen not found'
fi

HasDash() {
	for dashtest
	do	case $dashtest in
		-*)
			return 0;;
		esac
	done
	return 1
}

if HasDash ${1+"$@"}
then	dash=--
else	dash=
fi

# Check whether we want to change to the current user

currid=`id -un` && [ -n "$currid" ] || Fatal 'cannot get id'
if [ x"$currid" = x"$remoteuse" ]
then	msg=
	! $deletex || msg='. ignoring -U'
	! $untrusted || if [ -n "$msg" ]
	then	msg=$msg' -u'
	else	msg='. ignoring -u'
	fi
	[ -z "$script" ] || msg=$msg'. forcing -T'
	[ -z "$msg" ] || Warning "warning: remote user is the current user$msg"
	[ -z "${screen:++}" ] || DoExec "$screen" $dash ${1+"$@"}
	DoExec ${1+"$@"}
fi

# Calculate $script path

if [ -n "$script" ]
then	script=`PATH=/bin:/usr/bin::/sbin:/usr/sbin${PATH:+:}${PATH-} \
command -v script 2>/dev/null` && [ -n "$script" ] || Fatal '"script" not found'
fi

# Check for SUDO_ASKPASS

! $askpass || [ -z "${SUDO_ASKPASS:++}" ] || Push sudoargs -A

# Generate remote command and data to transfer

Push -c displays
Push -c transfer

CalcTransferAll() {
	eval "set -- a $displays"
	shift
	for a
	do	b=`xauth -q nlist "$a"` && [ -n "${b:++}" ] && \
			Push transfer "$b"
	done
}

CalcTransferUntrusted() {
	[ -n "${DISPLAY:++}" ] || return 0
	MkTemp || exit
	a=$tmpdir/untrusted
	(
		umask 077 && : >"$a"
	) || Fatal "cannot create $a"
	xauth -q -f "$a" generate "$DISPLAY" . untrusted timeout "$timeout" \
		|| Fatal 'failed to create untrusted permissions.
Perhaps your xorg-server was compiled without --enable-xcsecurity'
	b=`xauth -f "$a" nlist "$DISPLAY"` && [ -n "${b:++}" ] \
		|| Fatal 'failed to source data with untrusted permission'
	rm -- "$a"
	Push transfer "$b"
}

CalcDisplays() {
	[ -n "${DISPLAY:++}" ] || return 0
	Push -c displays "$DISPLAY"
	dispnum=${DISPLAY##*:}
	[ x"$dispnum" != x"$DISPLAY" ] || return 0
	disphost=${DISPLAY%:*}
	if [ -n "${disphost:++}" ]
	then	Push -c displays "$disphost/unix:$dispnum"
		if [ x"$disphost" = x'localhost' ]
		then	HOSTNAME=`hostname 2>/dev/null`
			Push -c displays "$HOSTNAME:$dispnum" "$HOSTNAME/unix:$dispnum"
		fi
	fi
}

if $untrusted
then	CalcDisplays
	CalcTransferUntrusted
elif $deletex
then	CalcDisplays
elif $xtransfer && ! $rootmode
then	CalcDisplays
	CalcTransferAll
fi

# Generate fifo
if [ -z "${transfer:++}" ]
then	fifo=
	RmTemp
else	MkTemp
	chmod -- 711 "$tmpdir"
	fifo=$tmpdir/fifo
	( umask 000 && mkfifo -- "$fifo" ) \
		|| Fatal "cannot create fifo $fifo"
fi

# Generate remote command:

# This must be a function, because we use set --
GenRemote() {
	if ! $xtransfer && ! $deletex
	then	if [ -n "${dash:++}" ] || HasDash "$script" "$screen"
		then	Push sudoargs --
		fi
		return
	fi
	Push sudoargs --
	Push sudoargs "$0"
	fifoarg=
	if [ -n "${fifo:++}" ]
	then	fifoarg=$fifo
	elif $xtransfer && $rootmode
	then	fifoarg='~'${XAUTHORITY:-"$HOME/.Xauthority"}
	fi
	disparg=
	! $xtransfer || disparg=${DISPLAY-}
	eval "set -- a $displays"
	shift
	Push sudoargs '-remotecall' "${SHELL:-sh}" \
		"$disparg" "$fifoarg" ${1+"$@"} '-dispend;'
	unset XAUTHORITY
}
GenRemote "$0"

if [ -n "$script" ]
then	script=`PATH='/bin:/sbin:/usr/bin:/usr/sbin' \
command -v script 2>/dev/null` && [ -n "$script" ] \
		|| Fatal '"script" not found'
	if [ -n "${screen:++}" ]
	then	Push -c sudocmd exec "$screen" $dash ${1+"$@"}
	else	Push -c sudocmd ${1+"$@"}
	fi
	Push sudoargs "$script" -q -e \
		${sudocmd:+-c} ${sudocmd:+"$sudocmd"} /dev/null
else	if [ -n "${screen:++}" ]
	then	Push -c sudoargs "$screen" $dash ${1+"$@"}
	else	Push -c sudoargs ${1+"$@"}
	fi
fi
eval "set -- a $sudoargs"
shift

if [ -z "${transfer:++}" ]
then	exec sudo ${1+"$@"}
	Fatal 'cannot exec sudo'
fi

# Free memory:
unset sudoargs sudocmd displays dash fifoarg disparg count have_random \
askpass untrusted deletex timeout xtransfer screen script \
checkenv loginenv rootmode
unset -f Echo MsgErr Warning Fatal Push DoExec \
AddAuthorities Troyan NonMatch ReadTransfer ParseFifo \
Version Usage MkTemp HasDash \
CalcTransferAll CalcTransferUntrusted CalcDisplays GenRemote 2>/dev/null

# Fill fifo:
{
	printf '%s\n%s' "${#transfer}" "$transfer" >"$fifo"
	RmTemp
} &

# Clearing the trap is a race, but in the worst case we leave tmpdir.
# This is better than removing tmpdir possibly twice (if it was already
# done by the background job): The latter might perhaps be exploited, since
# an attacker knows that we will remove a dir whose name is then known and
# which might be prepared then writable by the attacker.
ClearTrap
sudo ${1+"$@"}
retvalue=$?
[ -z "${fifo:++}" ] || ! test -p "$fifo" || {
	# If the fifo still exists, we empty it to finish our background job
	# and thus to clean tmpdir: Avoid removing tmpdir twice as noted above.
	cat -- "$fifo" >/dev/null
	wait
}
exit $retvalue
