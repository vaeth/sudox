#!/usr/bin/env sh
# (C) Martin V\"ath <martin@mvath.de>
set -u
set -f

# Some paranoia if /bin/sh is bash -
# after all, this script is highly security relevant:
[ -z "${BASH++}" ] || set -p
unset IFS BASH_ENV ENV SHELL_OPTS || exit 2
BASH_ENV=
ENV=
SHELL_OPTS=
[ -z "$BASH_ENV$ENV$SHELL_OPTS" ] || exit 2

# Actually, these are two scripts: The "main" script is documented
# in the "Usage" function below. However, this script is also
# called implicitly on the remote side.
# The "Usage" on the remote side is never printed by this script,
# because it is not supposed to be called by the user (and it might
# change in future versions).
# Currently, the syntax for the remote side is as follows:
#
# "$0" '-remotecall' "$SHELL" display1 display2 ... '-dispend;' \
#        'Name of fifo used to transfer data'|'' \
#        command [args for command]
#
# The actual authorization data is not passed as an arg but via the fifo.
# First, some helper functions needed for both parts of the script:

Echo() {
	printf '%s\n' "$*"
}

MsgErr() {
	Echo "$*" >&2
}

Warning() {
	MsgErr "${0##*/}: $*"
}

Fatal() {
	Warning "$*"
	exit 2
}

Push() {
	. push.sh
	Push "$@"
}

DoExec() {
	if [ $# -eq 0 ]
	then	exec "${SHELL:-sh}"
	else	Push -c mycmd ${1+"$@"}
		exec "${SHELL:-sh}" -c "$mycmd"
	fi
	Fatal "cannot execute ${SHELL:-sh}"
}

# Now the remote part of the script:

AddAuthorities() {
	for a
	do	printf '%s' "$a" | xauth nmerge -
	done
}

Troyan() {
	Fatal "$1. Probably some Troyan running"
}

ReadTransfer() {
	read -r count || Troyan 'unreadable fifo'
	case ${count:-x} in
	*[!0123456789]*)
		Troyan 'corruption with fifo';;
	esac
	if [ "$count" -gt 0 ]
	then	transfer=`dd bs="$count" count=1 2>/dev/null && echo x` || \
			Troyan 'corruption with fifo'
		transfer=${transfer%x}
		[ $count -eq ${#transfer} ] || Troyan 'corruption with fifo'
	fi
	eval "AddAuthorities $transfer"
	:
}

ParseSocket() {
	[ -z "${1:++}" ] && return
	test -p "$1" || Troyan "no fifo $1"
	ReadTransfer <"$1" || exit
}

if [ x"${1-}" = x'-remotecall' ]
then	shift
	SHELL=$1
	[ -n "$SHELL" ] && export SHELL
	shift
	while [ $# -gt 0 ]
	do	if [ x"${1-}" = x'-dispend;' ]
		then	shift
			break
		fi
		xauth -q remove "$1" >/dev/null 2>&1
		shift
	done
	ParseSocket "$1"
	shift
	SUDO_COMMAND=${*-}
	DoExec ${1+"$@"}
fi

# Now the main part of the script (i.e. the "server" side called by the user):

Version() {
	Echo 'sudox 4.1.0'
	exit 0
}

Usage() {
	Echo "Usage: ${0##*/} [options] [user [command]]
Similar to sudo -H -u user -s -- but transfer also X authority data.
Most options are passed to sudo, essentially with the following exceptions:
-l Clear STY/TMUX for the command/session (mnemonic: login environment)
-e Work only if not in a screen/tmux environment (STY/TMUX)
-p Without this option, -A is passed to sudo when SUDO_ASKPASS is set
-T Do not call \"script\" to open a new tty; security risk if interactive.
   If -xT are used but not -s/-S, then act similar to sudo -H -u user --
   This is useful if special entries in /etc/sudoers should be prepared.
-s Start a tmux (fallback to screen) session
-S Start a screen (fallback to tmux) session
-x Do not transfer any X authority data
-u Generate only an untrusted permission. (This requires that your xorg-server
   was compiled with --enable-xcsecurity.) You might combine this with:
-t TIMEOUT (in seconds). Time for which the untrusted permission is valid.
   The value 0 (default) means: forever
-U Delete all X authority data on the remote side - similar to -u -t 1
-V Print version
-h Print this help
If the specified user is empty, nothing is done (succesfully), so that
sudox -e '' can be used to only check the environment. In that case a
second argument (if provided) is used for the program name for -e failure"
	exit ${1:-1}
}

tmpdir=
RmTemp() {
	trap : EXIT HUP INT TERM
	[ -n "${tmpdir:++}" ] && test -d "$tmpdir" && rm -rf -- "$tmpdir"
	tmpdir=
	ClearTrap
}

retvalue=0
MyTrap() {
	RmTemp
	exit $retvalue
}

SetTrap() {
	trap MyTrap EXIT HUP INT TERM
}

ClearTrap() {
	trap - EXIT HUP INT TERM
}

MkTemp() {
	[ -n "${tmpdir:++}" ] && return
	SetTrap
	if command -v mktemp >/dev/null 2>&1
	then	tmpdir=`umask 077 && mktemp -d -- "${TMPDIR:-/tmp}/${0##*/}.XXXXXXXX"` \
			&& [ -n "${tmpdir:++}" ] && test -d "$tmpdir" && return
		ClearTrap
		ErrMessage 'cannot create temporary directory'
		return 2
	fi
	if [ -z "${have_random:++}" ]
	then	r=${RANDOM-}
		if [ x"$r" = x"${RANDOM-}" ] && [ x"$r" = x"${RANDOM-}" ]
		then	have_random=false
			r=`od -d -N2 /dev/random 2>/dev/null` || r=
			r=`printf '%s' $r`
			if [ -z "${r:++}" ]
			then	r=1
			else	r=$(( $r % 32768 ))
				[ "$r" -eq 0 ] && r=1
			fi
		else	have_random=:
		fi
		t=
	fi
	c=0
	while [ $c -le 999 ]
	do	if [ -n "${t:++}" ]
		then	if $have_random
			then	r=$RANDOM
			else	r=$(( $r * 13821 ))
				r=$(( $r % 32768 ))
			fi
		fi
		t=${TMPDIR:-}/tmp/${0##*/}.$$$c$r
		mkdir -m 700 -- "$t" && tmpdir=$t && return
		c=$(( $c + 1 ))
	done
	ClearTrap
	ErrMessage 'cannot create temporary directory'
	return 2
}

# Parse options

askpass=:
untrusted=
timeout=0
nox=false
screen=
script=:
checkenv=false
loginenv=false
Push -c sudoargs
OPTIND=1
while getopts "leTUut:xHsSyYh?Va:c:g:r:inkKbPAE" opt
do	case $opt in
	l)	loginenv=:;;
	e)	checkenv=:;;
	p)	askpass=false;;
	T)	script=false;;
	U)	untrusted=2;;
	u)	untrusted=1;;
	t)	timeout=$OPTARG;;
	x)	nox=:;;
	s)	screen='tmux screen';;
	S)	screen='screen tmux';;
	H)	:;;
	V)	Version;;
	[h?])	Usage;;
	[acgpr])
		Push sudoargs "-$opt" "$OPTARG";;
	*)	Push sudoargs "-$opt";;
	esac
done
shift $(( $OPTIND - 1 ))

# Check/modify environment first

if $checkenv && [ -n "${STY++}${TMUX++}" ]
then	if [ $# -eq 2 ] && [ -z "$1" ]
	then	name=$2
	else	name=${0##*/}
	fi
Fatal() {
	MsgErr "$name: terminating: $*"
	exit 1
}
	[ -z "${STY++}" ] || {
		[ -z "${TMUX++}" ] || Fatal 'screen and tmux both seem to be running.'
		Fatal 'screen seems to be running.'
	}
	Fatal 'tmux seems to be running.'
fi
! $loginenv || unset STY TMUX

# Parse remainder

Push sudoargs -H
remoteuse=root
if [ $# -gt 0 ]
then	remoteuse=$1
	[ -n "$remoteuse" ] || exit 0
	shift
	Push sudoargs "-u" "$remoteuse"
fi

# Check whether we want to change to the current user

currid=`id -un` && [ -n "$currid" ] || Fatal 'cannot get id'
if [ x"$currid" = x"$remoteuse" ]
then	Warning 'warning: remote user is the current user.
Assuming that this is a mistake: not modifying X authorization data
'
	DoExec ${1+"$@"}
fi

# Check for SUDO_ASKPASS

! $askpass || [ -z "${SUDO_ASKPASS:++}" ] || Push sudoargs -A

# Generate remote command and data to transfer

Push -c displays

CalcTransfer() {
	eval "set -- a $displays"
	shift
	for a
	do	b=`xauth -q nlist "$a"` && [ -n "${b:++}" ] && \
			Push transfer "$b"
	done
}

Push -c transfer
Push -c displays
if ! $nox
then	# Generate list of all displays to transfer
	if [ -n "${DISPLAY:++}" ]
	then	Push displays "$DISPLAY"
		dispnum=${DISPLAY##*:}
		if [ x"$dispnum" != x"$DISPLAY" ]
		then	disphost=${DISPLAY%:*}
			if [ -n "${disphost:++}" ]
			then	Push -c displays "$disphost/unix:$dispnum"
				if [ x"$disphost" = x'localhost' ]
				then	[ -z "${HOSTNAME:++}" ] && HOSTNAME=`hostname`
					Push -c displays "$HOSTNAME:$dispnum" "$HOSTNAME/unix:$dispnum"
				fi
			fi
		fi
	fi

	# Generate authorization data in $transfer
	if [ -n "${untrusted:++}" ]
	then	if [ x"$untrusted" = x'1' ] && [ -n "${DISPLAY:++}" ]
		then	MkTemp || exit
			a=$tmpdir/untrusted
			(
				umask 077 && : >"$a"
			) || Fatal "cannot create $a"
			xauth -q -f "$a" generate "$DISPLAY" . untrusted \
				timeout "$timeout" || Fatal \
'failed to create untrusted permissions.
Perhaps your xorg-server was compiled without --enable-xcsecurity'
			b=`xauth -f "$a" nlist "$DISPLAY"` \
			&& [ -n "${b:++}" ] || Fatal \
'failed to source data with untrusted permission'
			rm -- "$a"
			Push transfer "$b"
		fi
	else	CalcTransfer
	fi

	# Do not inherit .Xauthority file:
	unset XAUTHORITY
fi

# Generate fifo
if [ -z "${transfer:++}" ]
then	fifo=
	RmTemp
else	MkTemp
	chmod -- 711 "$tmpdir"
	fifo=$tmpdir/fifo
	( umask 000 && mkfifo -- "$fifo" ) \
		|| Fatal "cannot create fifo $fifo"
fi

# Generate remote command:

GenRemote() {
	Push sudoargs '--'
	! $nox || return 0
	Push sudoargs "$1"
	eval "set -- a $displays"
	shift
	Push sudoargs '-remotecall' "${SHELL:-sh}" ${1+"$@"} '-dispend;'
	Push sudoargs "$fifo"
}
GenRemote "$0"

Push -c sudocmd
if [ -n "${screen:++}" ]
then	for screenprg in $screen
	do	if screen=`export PATH='/bin:/sbin:/usr/bin:/usr/sbin'
		command -v "$screenprg" 2>/dev/null` && [ -n "${screen:++}" ]
		then	case $screenprg in
			screen)
				unset STY;;
			tmux)
				unset TMUX;;
			esac
			if $script
			then	Push sudocmd exec "$screen" '--'
			else	Push sudoargs "$screen" '--'
			fi
			screen=
			break
		fi
	done
	[ -z "${screen:++}" ] || Fatal 'tmux/screen not found'
fi
if $script
then	script=`export PATH='/bin:/sbin:/usr/bin:/usr/sbin'
	command -v script 2>/dev/null` && [ -n "$script" ] \
		|| Fatal '"script" not found'
	Push sudocmd ${1+"$@"}
	Push sudoargs "$script" -q -e \
		${sudocmd:+-c} ${sudocmd:+"$sudocmd"} /dev/null
else	Push sudoargs ${1+"$@"}
fi
eval "set -- a $sudoargs"
shift

if [ -z "${transfer:++}" ]
then	exec sudo ${1+"$@"}
	Fatal 'cannot exec sudo'
fi

# The fifo case:

# Fill fifo:

{
	printf '%s\n%s' "${#transfer}" "$transfer" >"$fifo"
	RmTemp
} &

# Clearing the trap is a race, but in the worst case we leave tmpdir.
# This is better than removing tmpdir possibly twice (if it was already
# done by the background job): The latter might perhaps be exploited, since
# an attacker knows that we will remove a dir whose name is then known and
# which might be prepared then writable by the attacker.
ClearTrap
sudo ${1+"$@"}
retvalue=$?
[ -z "${fifo:++}" ] || ! test -p "$fifo" || {
	# If the fifo still exists, we empty it to finish our background job
	# and thus to clean tmpdir: Avoid removing tmpdir twice as noted above.
	cat -- "$fifo" >/dev/null
	wait
}
exit $retvalue
