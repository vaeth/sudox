#!/usr/bin/env sh
# (C) Martin V\"ath <martin@mvath.de>
set -u
set -f

# Some paranoia if /bin/sh is bash -
# after all, this script is highly security relevant:
[ -z "${BASH++}" ] || set -p
unset IFS BASH_ENV ENV SHELL_OPTS || exit 2
BASH_ENV=
ENV=
SHELL_OPTS=
[ -z "$BASH_ENV$ENV$SHELL_OPTS" ] || exit 2

# Actually, these are two scripts: The "main" script is documented
# in the "Usage" function below. However, this script is also
# called implicitly on the remote side.
# The "Usage" on the remote side is never printed by this script,
# because it is not supposed to be called by the user (and it might
# change in future versions).
# Currently, the syntax for the remote side is as follows:
#
# "$0" '-remotecall' \
#        'Path to fifo'|'~XAUTHORITY'|'$VAR'|'' \
#        display1 display2 ... '-dispend;' \
#        "$SHELL" "$DISPLAY" \
#        command [args for command]
#
# The cookies are not passed as an arg but via the fifo, through VAR,
# or by setting XAUTHORITY.

# First, some helper functions needed for both parts of the script:

Echo() {
	printf '%s\n' "$*"
}

MsgErr() {
	Echo "$*" >&2
}

Warning() {
	MsgErr "${0##*/}: $*"
}

Fatal() {
	Warning "$*"
	exit 2
}

Push() {
	. push.sh
	Push "$@"
}

DoExec() {
	if [ $# -eq 0 ]
	then	exec "${SHELL:-sh}"
	else	Push -c mycmd ${1+"$@"}
		exec "${SHELL:-sh}" -c "$mycmd"
	fi
	Fatal "cannot execute ${SHELL:-sh}"
}

CheckVarname() {
	case ${1:-/} in
	[0123456789]*|*[!01234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_]*)
		Fatal "bad variable name $1";;
	esac
}

# Now the remote part of the script:

AddAuthorities() {
	for a
	do	printf '%s' "$a" | xauth nmerge -
	done
}

Troyan() {
	Fatal "$1. Probably some Troyan running"
}

NonMatch() {
	Fatal "$1. Client and server versions do not match"
}

ReadTransfer() {
	read -r count || Troyan 'unreadable fifo'
	case ${count:-x} in
	*[!0123456789]*)
		Troyan 'corruption with fifo';;
	esac
	if [ "$count" -gt 0 ]
	then	transfer=`dd bs="$count" count=1 2>/dev/null && echo x` || \
			Troyan 'corruption with fifo'
		transfer=${transfer%x}
		[ $count -eq ${#transfer} ] || Troyan 'corruption with fifo'
	fi
	eval "AddAuthorities $transfer"
	:
}

ParseFifo() {
	test -p "$1" || Troyan "no fifo $1"
	# || exit, because redirection might start a subshell
	ReadTransfer <"$1" || exit
}

ParseVariable() {
	CheckVarname "$1"
	eval "var=\${$1}"
	eval "AddAuthorities ${var%%sudox_magic_separator*}"
	var=${var#*sudox_magic_separator}
	case $var in
	'+'*)
		var=${var#?}
		eval "$1=\$var"
		return;;
	esac
	eval "unset $1"
}

if [ x"${1-}" = x'-remotecall' ]
then	shift
	[ $# -ge 2 ] || NonMatch 'not enough remote arguments'
	if [ -n "${XAUTHORITY++}" ]
	then	xauthority=$XAUTHORITY
		unset XAUTHORITY
	else	unset xauthority
	fi
	var=
	fifo=
	[ -z "$1" ] || case $1 in
	'~'*)
		xauthority=${1#?};;
	'$'*)
		var=${1#?};;
	*)
		unset xauthority
		fifo=$1;;
	esac
	shift
	while [ x"$1" != x'-dispend;' ]
	do	xauth -q remove "$1" >/dev/null 2>&1
		shift
		[ $# -gt 0 ] || NonMatch 'no "-dispend;"'
	done
	shift
	[ -z "${var:++}" ] || ParseVariable "$var"
	[ -z "${fifo:++}" ] || ParseFifo "$fifo"
	[ -z "${xauthority++}" ] || {
		XAUTHORITY=$xauthority
		export XAUTHORITY
	}
	[ $# -ge 2 ] || NonMatch 'not enough remote argument'
	# Set SHELL and DISPLAY _after_ ParseVariable
	# so that they can be used with -v
	SHELL=$1
	[ -z "${SHELL:++}" ] || export SHELL
	shift
	[ -z "${1:++}" ] || {
		DISPLAY=$1
		export DISPLAY
	}
	shift
	SUDO_COMMAND=${*-}
	DoExec ${1+"$@"}
fi

# Now the main part of the script (i.e. the "server" side called by the user):

Version() {
	Echo 'sudox 6.0.0'
	exit 0
}

Usage() {
	Echo "Usage: ${0##*/} [options] [user [command]]
Similar to sudo -H -u user -s -- but transfer also X authority data.
If the variable SUDOX_OPT is set, its options are used as default.
Most options are passed to sudo, essentially with the following exceptions:
-vVAR: Use VAR instead of a fifo to transfer information. This is more secure
   and the sudox process can terminate early, but you have to configure sudo
   to not reset the variable VAR. The previous content of VAR is kept.
   When you can, configure sudo correspondingly and export SUDOX_OPT=-vVAR
   in the shell startup file of all users.
   Recommended choices for VAR: TERM, LANG, DISPLAY, or SUDOX_OPT.
   A bad idea is XAUTHORITY or certain lowercase names: Such variables
   are modified by sudox, and collission can lead to all sort of problems.
-l Clear STY/TMUX for the command/session (mnemonic: login environment)
-s Start a tmux (fallback to screen) session
-S Start a screen (fallback to tmux) session
-e Work only if not in a screen/tmux environment (STY/TMUX)
-p Without this option, -A is passed to sudo when SUDO_ASKPASS is set
-T Do not call \"script\" to open a new tty; security risk if interactive.
   If -xT are used but not -s/-S/-U, then act similar to sudo -H -u user --
   This is useful if special entries in /etc/sudoers should be prepared.
-u Generate only an untrusted permission. (This requires that your xorg-server
   was compiled with --enable-xcsecurity.) This option implies -N
-tTIMEOUT (in seconds). Time for which the untrusted permission is valid.
   The value 0 (default) means: forever
   This option is ignored without -u
-U Delete all related X authority data of the new user (similar to -ut1).
   If combined with -r, the new user might have access to X anyway
-x Do not transfer any X authority data. If this option is used, -u is ignored
-R Use root mode: Assume that XAUTHORITY (defaults to ~/.Xauthority) is
   readable by the destination user, and transfer XAUTHORITY for X cookies.
   This makes it unnecessary to pass cookies through a fifo or variable
   (more secure and the sudox process can terminate early).
   This is the default if user is root and -u is not specified
-N Use non-root mode. Cancel -R even for root.
   This is the default if user is not root or -u is specified
-V Print version
-h Print this help
If the specified user is empty, nothing is done (succesfully), so that
sudox -e '' can be used to only check the environment. In that case a
second argument (if provided) is used for the program name for -e failure"
	exit ${1:-1}
}

tmpdir=
RmTemp() {
	trap : EXIT HUP INT TERM
	[ -n "${tmpdir:++}" ] && test -d "$tmpdir" && rm -rf -- "$tmpdir"
	tmpdir=
	ClearTrap
}

retvalue=0
MyTrap() {
	RmTemp
	exit $retvalue
}

ClearTrap() {
	trap - EXIT HUP INT TERM
}

MkTemp() {
	[ -n "${tmpdir:++}" ] && return
	trap MyTrap EXIT HUP INT TERM
	if command -v mktemp >/dev/null 2>&1
	then	tmpdir=`umask 077 && mktemp -d -- "${TMPDIR:-/tmp}/${0##*/}.XXXXXXXX"` \
			&& [ -n "${tmpdir:++}" ] && test -d "$tmpdir" && return
		ClearTrap
		ErrMessage 'cannot create temporary directory'
		return 2
	fi
	if [ -z "${have_random:++}" ]
	then	r=${RANDOM-}
		if [ x"$r" = x"${RANDOM-}" ] && [ x"$r" = x"${RANDOM-}" ]
		then	have_random=false
			r=`od -d -N2 /dev/random 2>/dev/null` || r=
			r=`printf '%s' $r`
			if [ -z "${r:++}" ]
			then	r=1
			else	r=$(( $r % 32768 ))
				[ "$r" -eq 0 ] && r=1
			fi
		else	have_random=:
		fi
		t=
	fi
	c=0
	while [ $c -le 999 ]
	do	if [ -n "${t:++}" ]
		then	if $have_random
			then	r=$RANDOM
			else	r=$(( $r * 13821 ))
				r=$(( $r % 32768 ))
			fi
		fi
		t=${TMPDIR:-}/tmp/${0##*/}.$$$c$r
		mkdir -m 700 -- "$t" && tmpdir=$t && return
		c=$(( $c + 1 ))
	done
	ClearTrap
	ErrMessage 'cannot create temporary directory'
	return 2
}

# Parse options


askpass=:
untrusted=false
deletex=false
timeout=0
xtransfer=:
screen=
script=:
checkenv=false
loginenv=false
rootmode=
variable=
Push -c sudoargs
ReadOpt() {
	OPTIND=1
	while getopts "v:lsSepuTUt:xRNHVh?a:c:g:r:inkKbPAE" opt
	do	case $opt in
		v)	variable=$OPTARG
			CheckVarname "$variable";;
		l)	loginenv=:;;
		s)	screen='tmux screen';;
		S)	screen='screen tmux';;
		e)	checkenv=:;;
		p)	askpass=false;;
		T)	script=;;
		u)	untrusted=:;;
		t)	timeout=$OPTARG;;
		U)	deletex=:;;
		x)	xtransfer=false;;
		R)	rootmode=:;;
		N)	rootmode=false;;
		H)	:;;
		V)	Version;;
		[h?])	Usage;;
		[acgr])
			Push sudoargs "-$opt" "$OPTARG";;
		*)	Push sudoargs "-$opt";;
		esac
	done
	optind=$OPTIND
	$sudox_opt || return 0
	shift $(( $optind - 1 ))
	[ $# -eq 0 ] || Fatal 'SUDOX_OPT must only contain options'
}
[ -z "${SUDOX_OPT:++}" ] || {
	sudox_opt=:
	ReadOpt $SUDOX_OPT
}
sudox_opt=false
ReadOpt ${1+"$@"}
shift $(( $optind - 1 ))

# Check/modify environment first

if $checkenv && [ -n "${STY++}${TMUX++}" ]
then	if [ $# -eq 2 ] && [ -z "$1" ]
	then	name=$2
	else	name=${0##*/}
	fi
Fatal() {
	MsgErr "$name: terminating: $*"
	exit 1
}
	[ -z "${STY++}" ] || {
		[ -z "${TMUX++}" ] || Fatal 'screen and tmux both seem to be running.'
		Fatal 'screen seems to be running.'
	}
	Fatal 'tmux seems to be running.'
fi
! $loginenv || unset STY TMUX

# Parse remainder

Push sudoargs -H
remoteuse=root
if [ $# -gt 0 ]
then	remoteuse=$1
	[ -n "$remoteuse" ] || exit 0
	shift
	Push sudoargs "-u" "$remoteuse"
fi

# Implicit option dependencies

$xtransfer || untrusted=false
! $untrusted || rootmode=false
[ -n "$rootmode" ] || if [ "$remoteuse" = 'root' ]
then	rootmode=:
else	rootmode=false
fi

# Calculate/check correct screen program, possibly unsetting environment

if [ -n "${screen:++}" ]
then	for screenprg in $screen
	do	if screen=`PATH=/bin:/usr/bin::/sbin:/usr/sbin${PATH:+:}${PATH-} \
command -v "$screenprg" 2>/dev/null` && [ -n "${screen:++}" ]
		then	case $screenprg in
			screen)
				unset STY;;
			tmux)
				unset TMUX;;
			esac
			break
		else	screen=
		fi
	done
	[ -z "${screen:++}" ] || Fatal 'tmux/screen not found'
fi

HasDash() {
	for dashtest
	do	case $dashtest in
		-*)
			return 0;;
		esac
	done
	return 1
}

if HasDash ${1+"$@"}
then	dash=--
else	dash=
fi

# Check whether we want to change to the current user

currid=`id -un` && [ -n "$currid" ] || Fatal 'cannot get id'
if [ x"$currid" = x"$remoteuse" ]
then	msg=
	! $deletex || msg='. ignoring -U'
	! $untrusted || if [ -n "$msg" ]
	then	msg=$msg' -u'
	else	msg='. ignoring -u'
	fi
	[ -z "$script" ] || msg=$msg'. forcing -T'
	[ -z "$msg" ] || Warning "warning: remote user is the current user$msg"
	[ -z "${screen:++}" ] || DoExec "$screen" $dash ${1+"$@"}
	DoExec ${1+"$@"}
fi

# Calculate $script path

if [ -n "$script" ]
then	script=`PATH=/bin:/usr/bin::/sbin:/usr/sbin${PATH:+:}${PATH-} \
command -v script 2>/dev/null` && [ -n "$script" ] || Fatal '"script" not found'
fi

# Check for SUDO_ASKPASS

! $askpass || [ -z "${SUDO_ASKPASS:++}" ] || Push sudoargs -A

# Generate remote command and data to transfer

Push -c displays
Push -c transfer

CalcTransferAll() {
	eval "set -- a $displays"
	shift
	for a
	do	b=`xauth -q nlist "$a"` && [ -n "${b:++}" ] && \
			Push transfer "$b"
	done
}

CalcTransferUntrusted() {
	[ -n "${DISPLAY:++}" ] || return 0
	MkTemp || exit
	a=$tmpdir/untrusted
	(
		umask 077 && : >"$a"
	) || Fatal "cannot create $a"
	xauth -q -f "$a" generate "$DISPLAY" . untrusted timeout "$timeout" \
		|| Fatal 'failed to create untrusted permissions.
Perhaps your xorg-server was compiled without --enable-xcsecurity'
	b=`xauth -f "$a" nlist "$DISPLAY"` && [ -n "${b:++}" ] \
		|| Fatal 'failed to source data with untrusted permission'
	rm -- "$a"
	Push transfer "$b"
}

CalcDisplays() {
	[ -n "${DISPLAY:++}" ] || return 0
	Push -c displays "$DISPLAY"
	dispnum=${DISPLAY##*:}
	[ x"$dispnum" != x"$DISPLAY" ] || return 0
	disphost=${DISPLAY%:*}
	if [ -n "${disphost:++}" ]
	then	Push -c displays "$disphost/unix:$dispnum"
		if [ x"$disphost" = x'localhost' ]
		then	HOSTNAME=`hostname 2>/dev/null`
			Push -c displays "$HOSTNAME:$dispnum" "$HOSTNAME/unix:$dispnum"
		fi
	fi
}

if $untrusted
then	CalcDisplays
	CalcTransferUntrusted
elif $deletex
then	CalcDisplays
elif $xtransfer && ! $rootmode
then	CalcDisplays
	CalcTransferAll
fi

# Generate fifo
if [ -z "${transfer:++}" ] || [ -n "$variable" ]
then	fifo=
	RmTemp
else	MkTemp
	chmod -- 711 "$tmpdir"
	fifo=$tmpdir/fifo
	( umask 000 && mkfifo -- "$fifo" ) \
		|| Fatal "cannot create fifo $fifo"
fi

# Generate remote command:

TransferVariable() {
	eval "$1=\$transfer'sudox_magic_separator'\${${1}++}\${${1}-}
	export $1"
}

# This must be a function, because we use set --
GenRemote() {
	if ! $xtransfer && ! $deletex
	then	if [ -n "${dash:++}" ] || HasDash "$script" "$screen"
		then	Push sudoargs --
		fi
		return
	fi
	Push sudoargs --
	Push sudoargs "$0"
	# Store SHELL and DISPLAY _before_ TransferVariable,
	# so that they can be used with -v
	shellarg=${SHELL:-sh}
	disparg=
	! $xtransfer || disparg=${DISPLAY-}
	transarg=
	if [ -n "${transfer:++}" ]
	then	if [ -n "${variable:++}" ]
		then	TransferVariable "$variable"
			transarg='$'$variable
		else	transarg=$fifo
		fi
	elif $xtransfer && $rootmode
	then	transarg='~'${XAUTHORITY:-"$HOME/.Xauthority"}
	fi
	eval "set -- a $displays"
	shift
	Push sudoargs '-remotecall' "$transarg" \
		${1+"$@"} '-dispend;' "$shellarg" "$disparg"
	unset XAUTHORITY
}
GenRemote "$0"

if [ -n "$script" ]
then	script=`PATH='/bin:/sbin:/usr/bin:/usr/sbin' \
command -v script 2>/dev/null` && [ -n "$script" ] \
		|| Fatal '"script" not found'
	if [ -n "${screen:++}" ]
	then	Push -c sudocmd exec "$screen" $dash ${1+"$@"}
	else	Push -c sudocmd ${1+"$@"}
	fi
	Push sudoargs "$script" -q -e \
		${sudocmd:+-c} ${sudocmd:+"$sudocmd"} /dev/null
else	if [ -n "${screen:++}" ]
	then	Push -c sudoargs "$screen" $dash ${1+"$@"}
	else	Push -c sudoargs ${1+"$@"}
	fi
fi
eval "set -- a $sudoargs"
shift

if [ -z "${fifo:++}" ]
then	exec sudo ${1+"$@"}
	Fatal 'cannot exec sudo'
fi

# Free memory:
unset sudoargs sudocmd displays dash transarg disparg count have_random \
askpass untrusted deletex timeout xtransfer screen script \
checkenv loginenv rootmode variable
unset -f Echo MsgErr Warning Fatal Push DoExec CheckVarname \
AddAuthorities Troyan NonMatch ReadTransfer ParseFifo ParseVariable \
Version Usage MkTemp HasDash \
CalcTransferAll CalcTransferUntrusted CalcDisplays \
TransferVariable GenRemote 2>/dev/null

# Fill fifo:
{
	printf '%s\n%s' "${#transfer}" "$transfer" >"$fifo"
	RmTemp
} &

# Clearing the trap is a race, but in the worst case we leave tmpdir.
# This is better than removing tmpdir possibly twice (if it was already
# done by the background job): The latter might perhaps be exploited, since
# an attacker knows that we will remove a dir whose name is then known and
# which might be prepared then writable by the attacker.
ClearTrap
sudo ${1+"$@"}
retvalue=$?
[ -z "${fifo:++}" ] || ! test -p "$fifo" || {
	# If the fifo still exists, we empty it to finish our background job
	# and thus to clean tmpdir: Avoid removing tmpdir twice as noted above.
	cat -- "$fifo" >/dev/null
	wait
}
exit $retvalue
